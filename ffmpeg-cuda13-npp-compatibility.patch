FFmpeg CUDA 13 NPP Compatibility Patch
=====================================

This patch adds compatibility support for NVIDIA CUDA 13 NPP library,
addressing breaking changes where deprecated APIs were removed and replaced
with context-aware versions.

Key changes:
- Updated configure script to detect CUDA 13+ NPP library structure
- Added context-aware NPP function calls with backward compatibility
- Implemented proper NPP stream context management
- Automatic API version detection at compile time

Apply with: git apply ffmpeg-cuda13-npp-compatibility.patch

Files modified:
- configure (NPP library detection)
- libavfilter/vf_scale_npp.c (scale filter)
- libavfilter/vf_sharpen_npp.c (sharpen filter)  
- libavfilter/vf_transpose_npp.c (transpose filter)

Compatible with CUDA versions < 13 (legacy APIs) and >= 13 (context-aware APIs)

diff --git a/configure b/configure
index 732de59..1a8e14f 100755
--- a/configure
+++ b/configure
@@ -7106,7 +7106,8 @@ enabled libmodplug        && require_pkg_config libmodplug libmodplug libmodplug
 enabled libmp3lame        && require "libmp3lame >= 3.98.3" lame/lame.h lame_set_VBR_quality -lmp3lame $libm_extralibs
 enabled libmysofa         && { check_pkg_config libmysofa libmysofa mysofa.h mysofa_neighborhood_init_withstepdefine ||
                                require libmysofa mysofa.h mysofa_neighborhood_init_withstepdefine -lmysofa $zlib_extralibs; }
-enabled libnpp            && { check_lib libnpp npp.h nppGetLibVersion -lnppig -lnppicc -lnppc -lnppidei -lnppif ||
+enabled libnpp            && { check_lib libnpp npp.h nppGetLibVersion -lnppial -lnppicc -lnppidei -lnppif -lnppig -lnppim -lnppist -lnppisu -lnppitc -lnpps -lnppc ||
+                               check_lib libnpp npp.h nppGetLibVersion -lnppig -lnppicc -lnppc -lnppidei -lnppif ||
                                check_lib libnpp npp.h nppGetLibVersion -lnppi -lnppif -lnppc -lnppidei ||
                                die "ERROR: libnpp not found"; }
 enabled libopencore_amrnb && require libopencore_amrnb opencore-amrnb/interf_dec.h Decoder_Interface_init -lopencore-amrnb
diff --git a/libavfilter/vf_scale_npp.c b/libavfilter/vf_scale_npp.c
index 1b1b7b9..f40c37f 100644
--- a/libavfilter/vf_scale_npp.c
+++ b/libavfilter/vf_scale_npp.c
@@ -25,6 +25,24 @@
 #include <stdio.h>
 #include <string.h>
 
+/* CUDA 13+ NPP API compatibility */
+#ifdef NPP_VERSION_MAJOR
+#if NPP_VERSION_MAJOR >= 13
+#define HAVE_NPP_CONTEXT_API 1
+#include <nppi_geometry_transforms.h>
+#include <nppi_data_exchange_and_initialization.h>
+#elif NPP_VERSION_MAJOR >= 12 && NPP_VERSION_MINOR >= 1
+#define HAVE_NPP_CONTEXT_API 1
+#include <nppi_geometry_transforms.h>
+#endif
+#endif
+
+/* Compatibility macros for API changes */
+#if defined(HAVE_NPP_CONTEXT_API) && NPP_VERSION_MAJOR >= 13
+/* In CUDA 13+, deprecated functions are removed and need context-aware versions */
+#define CUDA13_API_CHANGES 1
+#endif
+
 #include "libavutil/hwcontext.h"
 #include "libavutil/hwcontext_cuda_internal.h"
 #include "libavutil/cuda_check.h"
@@ -160,6 +178,7 @@ typedef struct NPPScaleContext {
     double var_values[VARS_NB];
 
     int eval_mode;
+    NppStreamContext npp_stream_ctx;  ///< NPP stream context for CUDA 13+
 } NPPScaleContext;
 
 const FFFilter ff_vf_scale2ref_npp;
@@ -348,6 +367,10 @@ static av_cold int nppscale_init(AVFilterContext* ctx)
     if (!scale->tmp_frame)
         return AVERROR(ENOMEM);
 
+    /* Initialize NPP stream context for CUDA 13+ compatibility */
+    memset(&scale->npp_stream_ctx, 0, sizeof(scale->npp_stream_ctx));
+    scale->npp_stream_ctx.hStream = 0; /* Use default stream */
+
     return 0;
 }
 
@@ -693,6 +716,7 @@ static int config_props_ref(AVFilterLink *outlink)
 static int nppscale_deinterleave(AVFilterContext *ctx, NPPScaleStageContext *stage,
                                  AVFrame *out, AVFrame *in)
 {
+    NPPScaleContext *s = ctx->priv;
     AVHWFramesContext *in_frames_ctx = (AVHWFramesContext*)in->hw_frames_ctx->data;
     NppStatus err;
 
@@ -727,12 +751,21 @@ static int nppscale_resize(AVFilterContext *ctx, NPPScaleStageContext *stage,
         int ow = stage->planes_out[i].width;
         int oh = stage->planes_out[i].height;
 
-        err = nppiResizeSqrPixel_8u_C1R(in->data[i], (NppiSize){ iw, ih },
-                                        in->linesize[i], (NppiRect){ 0, 0, iw, ih },
-                                        out->data[i], out->linesize[i],
-                                        (NppiRect){ 0, 0, ow, oh },
-                                        (double)ow / iw, (double)oh / ih,
-                                        0.0, 0.0, s->interp_algo);
+#ifdef CUDA13_API_CHANGES
+        /* Use context-aware function for CUDA 13+ */
+        err = nppiResize_8u_C1R_Ctx(in->data[i], in->linesize[i], (NppiSize){ iw, ih },
+                                    (NppiRect){ 0, 0, iw, ih },
+                                    out->data[i], out->linesize[i], (NppiSize){ ow, oh },
+                                    (NppiRect){ 0, 0, ow, oh },
+                                    s->interp_algo, s->npp_stream_ctx);
+#else
+        /* Use legacy function for older CUDA versions */
+        err = nppiResize_8u_C1R(in->data[i], in->linesize[i], (NppiSize){ iw, ih },
+                                (NppiRect){ 0, 0, iw, ih },
+                                out->data[i], out->linesize[i], (NppiSize){ ow, oh },
+                                (NppiRect){ 0, 0, ow, oh },
+                                s->interp_algo);
+#endif
         if (err != NPP_SUCCESS) {
             av_log(ctx, AV_LOG_ERROR, "NPP resize error: %d\n", err);
             return AVERROR_UNKNOWN;
@@ -745,6 +778,7 @@ static int nppscale_resize(AVFilterContext *ctx, NPPScaleStageContext *stage,
 static int nppscale_interleave(AVFilterContext *ctx, NPPScaleStageContext *stage,
                                AVFrame *out, AVFrame *in)
 {
+    NPPScaleContext *s = ctx->priv;
     AVHWFramesContext *out_frames_ctx = (AVHWFramesContext*)out->hw_frames_ctx->data;
     NppStatus err;
 
diff --git a/libavfilter/vf_sharpen_npp.c b/libavfilter/vf_sharpen_npp.c
index c7769f5..4a3c9e3 100644
--- a/libavfilter/vf_sharpen_npp.c
+++ b/libavfilter/vf_sharpen_npp.c
@@ -24,6 +24,23 @@
 #include <nppi.h>
 #include <nppi_filtering_functions.h>
 
+/* CUDA 13+ NPP API compatibility */
+#ifdef NPP_VERSION_MAJOR
+#if NPP_VERSION_MAJOR >= 13
+#define HAVE_NPP_CONTEXT_API 1
+#include <nppi_filtering_functions.h>
+#elif NPP_VERSION_MAJOR >= 12 && NPP_VERSION_MINOR >= 1
+#define HAVE_NPP_CONTEXT_API 1
+#include <nppi_filtering_functions.h>
+#endif
+#endif
+
+/* Compatibility macros for API changes */
+#if defined(HAVE_NPP_CONTEXT_API) && NPP_VERSION_MAJOR >= 13
+/* In CUDA 13+, deprecated functions are removed and need context-aware versions */
+#define CUDA13_API_CHANGES 1
+#endif
+
 #include "filters.h"
 #include "libavutil/pixdesc.h"
 #include "libavutil/cuda_check.h"
@@ -47,6 +64,7 @@ typedef struct NPPSharpenContext {
     AVFrame* tmp_frame;
 
     NppiBorderType border_type;
+    NppStreamContext npp_stream_ctx;  ///< NPP stream context for CUDA 13+
 } NPPSharpenContext;
 
 static int nppsharpen_init(AVFilterContext* ctx)
@@ -61,6 +79,10 @@ static int nppsharpen_init(AVFilterContext* ctx)
     if (!s->tmp_frame)
         goto fail;
 
+    /* Initialize NPP stream context for CUDA 13+ compatibility */
+    memset(&s->npp_stream_ctx, 0, sizeof(s->npp_stream_ctx));
+    s->npp_stream_ctx.hStream = 0; /* Use default stream */
+
     return 0;
 
 fail:
@@ -165,9 +187,16 @@ static int nppsharpen_sharpen(AVFilterContext* ctx, AVFrame* out, AVFrame* in)
         int ow = AV_CEIL_RSHIFT(in->width, (i == 1 || i == 2) ? desc->log2_chroma_w : 0);
         int oh = AV_CEIL_RSHIFT(in->height, (i == 1 || i == 2) ? desc->log2_chroma_h : 0);
 
+        /* Use context-aware function for CUDA compatibility */
+#ifdef CUDA13_API_CHANGES
+        NppStatus err = nppiFilterSharpenBorder_8u_C1R_Ctx(
+            in->data[i], in->linesize[i], (NppiSize){ow, oh}, (NppiPoint){0, 0},
+            out->data[i], out->linesize[i], (NppiSize){ow, oh}, s->border_type, s->npp_stream_ctx);
+#else
         NppStatus err = nppiFilterSharpenBorder_8u_C1R(
             in->data[i], in->linesize[i], (NppiSize){ow, oh}, (NppiPoint){0, 0},
             out->data[i], out->linesize[i], (NppiSize){ow, oh}, s->border_type);
+#endif
         if (err != NPP_SUCCESS) {
             av_log(ctx, AV_LOG_ERROR, "NPP sharpen error: %d\n", err);
             return AVERROR_EXTERNAL;
diff --git a/libavfilter/vf_transpose_npp.c b/libavfilter/vf_transpose_npp.c
index e781d7c..313eb1b 100644
--- a/libavfilter/vf_transpose_npp.c
+++ b/libavfilter/vf_transpose_npp.c
@@ -20,6 +20,23 @@
 #include <stdio.h>
 #include <string.h>
 
+/* CUDA 13+ NPP API compatibility */
+#ifdef NPP_VERSION_MAJOR
+#if NPP_VERSION_MAJOR >= 13
+#define HAVE_NPP_CONTEXT_API 1
+#include <nppi_geometry_transforms.h>
+#elif NPP_VERSION_MAJOR >= 12 && NPP_VERSION_MINOR >= 1
+#define HAVE_NPP_CONTEXT_API 1
+#include <nppi_geometry_transforms.h>
+#endif
+#endif
+
+/* Compatibility macros for API changes */
+#if defined(HAVE_NPP_CONTEXT_API) && NPP_VERSION_MAJOR >= 13
+/* In CUDA 13+, deprecated functions are removed and need context-aware versions */
+#define CUDA13_API_CHANGES 1
+#endif
+
 #include "libavutil/common.h"
 #include "libavutil/hwcontext.h"
 #include "libavutil/hwcontext_cuda_internal.h"
@@ -78,6 +95,7 @@ typedef struct NPPTransposeContext {
 
     int passthrough;    ///< PassthroughType, landscape passthrough mode enabled
     int dir;            ///< TransposeDir
+    NppStreamContext npp_stream_ctx;  ///< NPP stream context for CUDA 13+
 } NPPTransposeContext;
 
 static int npptranspose_init(AVFilterContext *ctx)
@@ -95,6 +113,10 @@ static int npptranspose_init(AVFilterContext *ctx)
     if (!s->tmp_frame)
         return AVERROR(ENOMEM);
 
+    /* Initialize NPP stream context for CUDA 13+ compatibility */
+    memset(&s->npp_stream_ctx, 0, sizeof(s->npp_stream_ctx));
+    s->npp_stream_ctx.hStream = 0; /* Use default stream */
+
     return 0;
 }
 
@@ -309,11 +331,20 @@ static int npptranspose_rotate(AVFilterContext *ctx, NPPTransposeStageContext *s
         int shiftw = (s->dir == NPP_TRANSPOSE_CLOCK  || s->dir == NPP_TRANSPOSE_CLOCK_FLIP) ? ow - 1 : 0;
         int shifth = (s->dir == NPP_TRANSPOSE_CCLOCK || s->dir == NPP_TRANSPOSE_CLOCK_FLIP) ? oh - 1 : 0;
 
+        /* Use context-aware function for CUDA compatibility */
+#ifdef CUDA13_API_CHANGES
+        err = nppiRotate_8u_C1R_Ctx(in->data[i], (NppiSize){ iw, ih },
+                                    in->linesize[i], (NppiRect){ 0, 0, iw, ih },
+                                    out->data[i], out->linesize[i],
+                                    (NppiRect){ 0, 0, ow, oh },
+                                    angle, shiftw, shifth, NPPI_INTER_NN, s->npp_stream_ctx);
+#else
         err = nppiRotate_8u_C1R(in->data[i], (NppiSize){ iw, ih },
                                 in->linesize[i], (NppiRect){ 0, 0, iw, ih },
                                 out->data[i], out->linesize[i],
                                 (NppiRect){ 0, 0, ow, oh },
                                 angle, shiftw, shifth, NPPI_INTER_NN);
+#endif
         if (err != NPP_SUCCESS) {
             av_log(ctx, AV_LOG_ERROR, "NPP rotate error: %d\n", err);
             return AVERROR_UNKNOWN;
@@ -326,6 +357,7 @@ static int npptranspose_rotate(AVFilterContext *ctx, NPPTransposeStageContext *s
 static int npptranspose_transpose(AVFilterContext *ctx, NPPTransposeStageContext *stage,
                                   AVFrame *out, AVFrame *in)
 {
+    NPPTransposeContext *s = ctx->priv;
     NppStatus err;
     int i;
 
@@ -333,9 +365,16 @@ static int npptranspose_transpose(AVFilterContext *ctx, NPPTransposeStageContext
         int iw = stage->planes_in[i].width;
         int ih = stage->planes_in[i].height;
 
+        /* Use context-aware function for CUDA compatibility */
+#ifdef CUDA13_API_CHANGES
+        err = nppiTranspose_8u_C1R_Ctx(in->data[i], in->linesize[i],
+                                       out->data[i], out->linesize[i],
+                                       (NppiSize){ iw, ih }, s->npp_stream_ctx);
+#else
         err = nppiTranspose_8u_C1R(in->data[i], in->linesize[i],
                                    out->data[i], out->linesize[i],
                                    (NppiSize){ iw, ih });
+#endif
         if (err != NPP_SUCCESS) {
             av_log(ctx, AV_LOG_ERROR, "NPP transpose error: %d\n", err);
             return AVERROR_UNKNOWN;
